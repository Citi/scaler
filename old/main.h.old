// C
#include <cstddef>
#include <cstdint>
#include <cstring>

// C++
#include <thread>
#include <queue>
#include <vector>
#include <semaphore>
#include <optional>
#include <atomic>
#include <mutex>
#include <optional>
#include <shared_mutex>
#include <iostream>
#include <source_location>
#include <string>

// System
#include <sys/socket.h>
#include <sys/eventfd.h>
#include <sys/epoll.h>
#include <sys/signalfd.h>
#include <sys/un.h>
#include <sys/timerfd.h>

#include <fcntl.h>
#include <poll.h>
#include <signal.h>

#include <arpa/inet.h>
#include <netinet/tcp.h>

// Third-party
#include "third_party/concurrentqueue.h"
#include "third_party/blockingconcurrentqueue.h"

// we need to change certain settings depending on if we're compiling as C or C++
#ifdef COMPILE

// 5ca1ab1e = scalable
static uint8_t MAGIC[4] = {0x5c, 0xa1, 0xab, 0x1e};

#define ENUM enum class
#else
#define ENUM enum
#endif

using moodycamel::BlockingConcurrentQueue;
using moodycamel::ConcurrentQueue;

// max message size to receive or send in bytes
#define MAX_MSG_SIZE 500 * 1024 * 1024 // 500M

struct Client;
struct Peer;
struct Message;
struct SendMsg;

struct Session;
struct IntraProcessClient;

struct EpollData
{
    int fd;
    EpollType type;

    union
    {
        void *ptr;
        Client *client;
        IntraProcessClient *inproc;
        Peer *peer;
    };
};

ENUM ReadResult{
    Read,
    TimedOut,
    NoData,
    Disconnect};

ENUM WriteResult{
    Written,
    Disconnected};

// public API
void session_init(Session *session, size_t num_threads);
void session_destroy(Session *session);

// private API
void io_thread_main(ThreadContext *ctx, size_t id);
ReadResult read_message(int fd, Bytes *data, bool stop_if_no_data, int timeout);
ReadResult readexact(int fd, uint8_t *data, size_t len, bool stop_if_no_data);
WriteResult write_message(int fd, Bytes *data);
WriteResult writeall(int fd, const uint8_t *data, size_t len);
void serialize_u32(uint32_t x, uint8_t buffer[4]);
void deserialize_u32(const uint8_t buffer[4], uint32_t *x);
bool client_connect_(Client *client, sockaddr_storage &&addr, int tries);
void set_sock_opts(int fd);



ENUM SendResult{
    Sent,
    Muted};

// public API
void client_init(Session *session, Client *binder, Transport transport, uint8_t *identity, size_t len, ConnectorType type);
void client_bind(Client *binder, const char *host, uint16_t port);
void client_connect(Client *binder, const char *addr, uint16_t port);
void client_send(void *future, Client *binder, uint8_t *to, size_t to_len, uint8_t *data, size_t data_len);
void client_recv(void *future, Client *binder);
void client_destroy(Client *binder);
void message_destroy(Message *recv);

void client_send_sync(Client *binder, uint8_t *to, size_t to_len, uint8_t *data, size_t data_len);
void client_recv_sync(Client *client, Message *msg);

void intraprocess_init(Session *session, IntraProcessClient *inproc, uint8_t *identity, size_t len);
void intraprocess_recv_async(void *future, IntraProcessClient *inproc);
void intraprocess_recv_sync(IntraProcessClient *inproc, Message *msg);
void intraprocess_send(IntraProcessClient *inproc, uint8_t *data, size_t len);
void intraprocess_connect(IntraProcessClient *inproc, const char *addr, size_t len);
void intraprocess_bind(IntraProcessClient *inproc, const char *addr, size_t len);

// Python callbacks
void future_set_result(void *future, void *data);

// private API
void peer_destroy(Peer *peer);
int fd_wait(int fd, int timeout, short int events);
uint8_t *datadup(const uint8_t *data, size_t len);

// todo: make this a method of Client
SendResult client_send_(Client *client, Message &&msg);

// epoll handlers
void client_send_event(Client *binder);
void client_recv_event(Client *binder);
void client_peer_recv_event(Peer *peer);
void client_listener_event(Client *binder);
void intraprocess_recv_event(IntraProcessClient *inproc);

void message_destroy(Message &message);

